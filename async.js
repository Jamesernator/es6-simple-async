// Generated by CoffeeScript 1.10.0

/* Author James "The Jamesernator" Browning
    2016
 */

(function() {
  "use strict";
  var async,
    slice = [].slice;

  async = function(genFunc) {
    var asyncFunc;
    return asyncFunc = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var gen, iter;
          gen = genFunc.apply(_this, args);
          iter = (function*() {
            var awaiting, done, err, error, error1, isError, ref, ref1, ref2, result, value;
            result = void 0;
            isError = false;
            while (true) {
              if (!isError) {
                try {
                  ref = gen.next(result), value = ref.value, done = ref.done;
                } catch (error) {
                  err = error;
                  reject(err);
                }
              } else {
                try {
                  ref1 = gen["throw"](result), value = ref1.value, done = ref1.done;
                } catch (error1) {
                  err = error1;
                  reject(err);
                }
              }
              if (done) {
                resolve(value);
                return;
              }
              awaiting = Promise.resolve(value);
              ref2 = (yield awaiting.then(function(_result) {
                return iter.next({
                  result: _result,
                  isError: false
                });
              })["catch"](function(err) {
                return iter.next({
                  result: err,
                  isError: true
                });
              })), result = ref2.result, isError = ref2.isError;
            }
          })();
          return iter.next();
        };
      })(this));
    };
  };

  async.run = function(func, errCallback) {
    if (errCallback == null) {
      errCallback = console.log;
    }

    /* This tries running the async function given and if it
        fails it calls the errCallback with the error given
        by the async function
     */
    return async(function*() {
      var err, error;
      try {
        return (yield async(func)());
      } catch (error) {
        err = error;
        return errCallback(err);
      }
    })();
  };

  async.main = function(func) {

    /* Although async.run has errCallback as console.log we'll just print
        the stack
     */
    return async.run(func, function(err) {
      return console.log(err.stack);
    });
  };

  async.from = function(iterable) {

    /* Creates a async function from an existing iterable */
    var genFunc;
    genFunc = function*() {
      return (yield* iterable);
    };
    return async(genFunc);
  };

  async["do"] = async.run;

  Object.defineProperty(async, "name", {
    value: "async"
  });

  if (typeof module !== "undefined" && module !== null) {
    module.exports = async;
  } else {
    window.async = async;
  }

}).call(this);
